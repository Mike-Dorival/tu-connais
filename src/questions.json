[
  {
    "id": 1,
    "type": "js",
    "questions": [
      {
        "id": 1,
        "question": "Peut on réassigner une valeur avec une const ?",
        "choice": ["oui", "non", "oui avec certains types", "la réponse D"],
        "answer": "oui avec certains types",
        "explanation": "Ce qu’il faut comprendre dans tout ça, c’est que quand vous déclarer une const vous créer une référence à cette valeur. Mais lorsque que vous créer un objet la référence sera attribué à l’objet pas à ce qu’il contient, ce qui permet justement de changer les valeurs à l'intérieur de l’objet puisque que l’objet n'a pas changé de référence et nous permet bien de modifier les propriétés de l’objet, ceci est également valable pour un tableau. "
      },
      {
        "id": 2,
        "question": "Que renvoi ce code ?",
        "code": "const [firstname, ,lastName] = 'John Doe Marshall'.split(' '); \n console.log(firstname, lastName)",
        "choice": ["John Marshall", "John Doe Marshall", "John Doe", "renvoi une erreur"],
        "answer": "John Marshall",
        "explanation": "Après la virgule, si on ne donne pas de nom dans notre destructuring il ignore tout simplement."
      },
      {
        "id": 3,
        "question": "Peut on renommer une clé lorsqu'on destructure un objet ?",
        "choice": ["oui", "non"],
        "answer": "oui",
        "explanation": "Effectivement, on peut d'ores et déjà le faire un exemple \n const obj = {name: toto, age: 27}; \n const {name: prenom} = obj; \n console.log(prenom); // toto"
      },
      {
        "id": 4,
        "question": "Que renvoi ce code ?",
        "code": "true + true",
        "choice": ["NaN", "2", "true", "0"],
        "answer": "2",
        "explanation": "Le + dans une opération va transformer le booléen true en number 1 \n et justement en testant 1 === +true cela nous donne bien true."
      },
      {
        "id": 5,
        "question": "Que renvoi ce code ?",
        "code": "14 > 13 > 12",
        "choice": ["true", "false"],
        "answer": "false",
        "explanation": "c'est false car ce qui se passe c'est que d'abord il fait (14 > 13) \n ce qui donne true mais dans une opération en js true = 1 donc 1 > 12 = false du coup l'opération est false"
      },
      {
        "id": 6,
        "question": "Que renvoi ce code ?",
        "code": "[ 10, 1, 3 ].sort()",
        "choice": ["true", "[1, 10, 3]", "[1, 3, 10]", "[10, 3, 1]"],
        "answer": "[1, 10, 3]",
        "explanation": "De base .sort va trier un array comme si tous les éléments étaient de type string. \n donc '1' > '10' = false [1] et '3' > '10' = true donc a bien [1, 10, 3]"
      }
    ]
  },
  {
    "id": 2,
    "type": "react",
    "questions": [
      {
        "id": 1,
        "question": "Le hook useMemo est l'équivalent de quel module en class ?",
        "choice": ["Component", "componentDidUpdate", "PureComponent", "la réponse D"],
        "answer": "PureComponent",
        "explanation": "Dans une class, le PureComponent à le meme comportement que useMemo il est utiliser dans le cadre d'un optimisation de vos composants il se base sur un systeme de cache est va comparer le dernier state et le nouveau state si il y'a chanegement alors on a un render sinon pas de render"
      }
    ]
  }
]
